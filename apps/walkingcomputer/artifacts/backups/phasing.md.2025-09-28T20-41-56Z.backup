# Project Phasing

## Phase 1: WebGPU Boilerplate
So first we'll just get a triangle on screen to prove WebGPU is alive. We'll spin up a bare-bones wgpu-rs project, pick the Vulkan backend on desktop and fall back to WebGPU on Chrome, then draw a single RGB triangle in a 600×400 canvas.  
**Definition of Done:** open `cargo run` and you should see a colored triangle in a window; if you open the same page in Chrome via `wasm-pack` you get an identical triangle with no console errors.

## Phase 2: WASM Bridge
Then we'll wire the GPU code to the browser without exposing Rust internals. We'll compile the core crate to `wasm32-unknown-unknown` with `wasm-pack`, expose one `prove_transfer(sender, receiver, amount) -> Vec<u8>` function through `wasm-bindgen`, and keep the WebGPU context alive inside the module so JavaScript only sees bytes in and bytes out.  
**Definition of Done:** in the dev-console call `window.zkvm.proveTransfer("alice", "bob", 42)` and it should return a Uint8Array of length > 0 without throwing.

## Phase 3: Native Field Math
Next we'll port a 25519 scalar-field implementation to WGSL so it runs on the GPU. We'll write modular add, sub, mul, and Montgomery reduction in WGSL, test them against `curve25519-dalek` on the CPU, and launch a compute shader that processes 1024 scalars in parallel.  
**Definition of Done:** run `cargo test field::wgsl::tests::bench_1024` and the GPU result should match the CPU result within 1 ms on an M1 MacBook.

## Phase 4: MSM Primitives
After that we'll bolt on a WebGPU multi-scalar-multiplication for BN254. We'll adapt the cuZK bucket-method to WGSL, store points in affine Montgomery form, run 2^14 scalars in work-groups of 256, and pipe random scalars from JavaScript.  
**Definition of Done:** call `window.zkvm.msmBN254(points, scalars)` with 16 k inputs and it should finish in < 300 ms on Chrome/RTX 3060, returning a G1 element that equals the same MSM run by `@noble/curves`.

## Phase 5: ZK-VM Circuit
Finally we'll hard-code a tiny balance-update circuit. We'll pre-compile a rank-1 constraint system that checks `old_balance >= amount && new_balance == old_balance - amount && sig_valid`, feed the witness from JavaScript, run the polynomial evaluation on the same WebGPU queue, and emit a 128-byte Groth16 proof plus public inputs.  
**Definition of Done:** paste the emitted proof and public inputs into the verifier contract at `0x1234…` on Goerli and the transaction should succeed, showing "Proof verified" in the block explorer.