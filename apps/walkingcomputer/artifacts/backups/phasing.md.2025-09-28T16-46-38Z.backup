# Project Phasing

## Phase 1: Core ISA & Tracer
So first we'll lock down a minimal 32-bit RISC ISA that only needs about 40 opcodes, then bang out a Rust tracer that records every register change and memory access in a fast FIFO. We'll wire Criterion benches to each opcode so CI screams if anything slows down, and stash the traces in flat buffers so the prover can slurp them later without copying. When this phase is done, you'll be able to run a fibonacci binary and watch the tracer spit out a cycle-count report under 100k cycles.

## Phase 2: Arithmetic Backend
Next we'll drop in the finite-field turbo, picking either Plonky3 or halo2 depending on which one benches faster on your GPU. We'll hand-roll the assembly for the big-three ops (mul, add, sub) and expose them through the arkworks traits so the rest of the VM stays generic. Every custom gate gets its own micro-bench and a quick correctness test that compares against a naive bigint impl. Once complete, you can test by running cargo bench --bench ff_ops and seeing sub-microsecond times for 256-bit modular multiply.

## Phase 3: Constraint Generator
Then we'll convert the trace into a constraint matrix without ever cloning it. We'll stream each row through a tiny DSL that emits Plonky3 custom gates for ALU ops and lookup arguments for memory consistency, keeping the trace width under 200 columns so proof size stays small. A differential test will re-execute the same trace in the DSL and in plain Rust, asserting identical final state. When this phase is done, you'll be able to point the generator at a 1-million-cycle trace and get a constraint file in under five seconds.

## Phase 4: Prover & Verifier
After that we'll glue the constraint system to the actual SNARK prover, letting it run on CUDA if available or fall back to 96 parallel CPU threads. We'll checkpoint the proving key to disk so CI can skip regeneration, and ship a tiny verifier contract in Solidity that we test against anvil in every pull request. Once complete, you can test by running a single command that proves a 10k-cycle program, verifies on-chain, and prints both the proof size (target < 200kB) and verification time (target < 50ms).

## Phase 5: REST & SDK
Finally we'll wrap the whole thing in a skinny HTTP layer so you can POST ELF binaries and get back proofs as base64, plus a Rust SDK that hides every low-level knob behind a three-line API. We'll add tokio, swagger docs, and rate-limit middleware, but keep the critical path in pure async Rust so throughput stays above 100 proofs per second on a 16-core box. When this phase is done, you'll be able to curl the endpoint with a hello-world ELF and receive a verified proof in under a second.