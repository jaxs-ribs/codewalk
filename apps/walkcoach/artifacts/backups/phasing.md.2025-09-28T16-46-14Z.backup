# Project Phasing

## Phase 1: Core VM Skeleton
So first we'll lay down the absolute basics: a tiny RISC-V decoder that can turn 32-bit words into ADD, SUB, AND, OR, XOR, and JAL ops, plus a register file of 32 x 32-bit cells. We'll wrap it in a minimal AIR with one row per instruction, write Rust unit tests that feed hand-crafted hex blobs and assert the final register state, and hook everything up to cargo-nextest so you can type `cargo t` and watch 100-plus micro-tests pass in milliseconds. When this phase is done, you'll be able to run `cargo test` and see the VM correctly execute a tiny assembly file that adds two numbers and parks the result in x5.

## Phase 2: Memory & Trace
Next we'll add a 64-KiB byte-addressed memory, a Poseidon-based Merkle tree that commits to every chunk, and a trace generator that emits (addr, r/w, old, new) tuples. The AIR grows to two tables—one for instructions, one for memory—and we add bus-type lookup arguments so the CPU can prove it read the right value. We'll write property-based tests with proptest to hammer random load/store patterns, plus a differential tester that compares our trace against QEMU's memory log. Once complete, you can test by running `cargo test memory -- --nocapture` and watch it pass a million random memory ops while keeping the Merkle root in sync.

## Phase 3: Proof Pipeline
Then we'll wire the trace into a real proof system: we'll pick Plonk with Poseidon as the native hash, build a rust-witness crate that serializes the trace into field elements, and add a `prove` binary that takes the trace, runs the prover, and spits out a 200-kB proof on disk. We'll gate every big circuit behind feature flags so `cargo test` stays fast, but `cargo test --features full` will actually run the prover on 2^14 rows and verify it in under five seconds on a laptop. When this phase is done, you'll be able to type `cargo run --release -- prove --trace out.trace` and get a verified proof plus the public inputs hash printed to stdout.

## Phase 4: This is a placeholder