# Project Phasing

## Phase 1: Core ISA & Memory
So first we'll wire up a minimal 32-bit RISC-V decoder that can handle ADD, SUB, AND, OR, LW, SW, BEQ, JAL plus the standard 32 registers, then tack on a simple linear memory that starts at 0x8000_0000 and grows up to 16 MB with a basic page-table so we can track merkle-ized bytes for the proof. We'll build a tiny assembler that turns "add x5,x6,x7" into the right 32-bit word, hook it into Rust's no-std so we can run it in a test harness, and make sure the PC increments, flags get set, and memory writes show up in the trace log. When this phase is done, you'll be able to feed a hand-written RISC-V hex file and watch the VM step through instructions while spitting a JSON trace.

## Phase 2: Constraint Builder
Next we'll map every RISC-V opcode into Plonkish gates: one selector polynomial for the instruction type, a set of wire polynomials for rs1, rs2, rd, immediate, plus a mini lookup table for 12-bit immediates so we don't explode the gate count, and we'll SHA-256 compress the entire execution trace into a transcript that the prover can commit to. We'll write a Rust builder API that feels like "cs.assign(add_gate, left, right, dst)" and have it spit out a rank-1 constraint system that we can already feed into arkworks for a dummy proof. Once complete, you can test by compiling a two-instruction program and seeing the constraint count print 8 rows instead of thousands.

## Phase 3: Prover & Verifier
Then we'll swap SHA-256 for Poseidon over the BLS12-381 scalar field, wire up the KZG ceremony, implement the linear-time prover that commits to the trace polynomials, opens them at a random point, and produces a 1.5 kB proof that verifies in 5 ms on a single CPU core. We'll add recursive-friendly cycles so we can prove the verifier inside the VM itself, wrap the whole thing in a CLI that takes "vm.prove(elf)" and spits "proof.bin", and expose a tiny verify crate that returns true/false. When this phase is done, you'll be able to run "zkvm prove fibonacci.elf" followed by "zkvm verify proof.bin" and see the green checkmark.

## Phase 4: SDK & Examples
After that we'll ship a Rust guest crate with macros like "#[zk_entry] fn main() -> u32" that cross-compiles to our rv32 target, a std-like crate that gives Vec, HashMap, and println that all compile to pure arithmetic so the prover can track them, and five examples: fibonacci, merkle-proof inclusion, Ed25519 signature verification, a tiny chess move validator, and a recursive proof that verifies another proof. We'll bundle a VS Code extension that shows constraint counts inline and a single "cargo zkvm build" that spits out the ELF plus a size report. Once complete, you'll open the chess example, hit build, and see "constraints used: 47k, proof size: 1.4 kB" in the terminal.

## Phase 5: Perf & Recursion
Finally we'll add a lookup argument for 8-bit XOR so we can drop the bitwise gate count by 5Ã—, parallelize the prover with Rayon so 16 cores crunch a million cycles in under 3 seconds, compress several proofs into one via a recursive verifier gadget written inside the guest, and publish nightly benchmarks on EC2 so we can track cycles-per-second regressions. We'll expose a server mode that listens on localhost:9989, accepts ELF bytes over POST, streams progress, and returns the proof plus the cycles count, and we'll gate landing PRs on not regressing more than 5 %. When this phase is done, you'll POST the recursive demo, get back a proof in two seconds, and the verify endpoint will say "cycles: 1.2M, recursion depth: 3, verified: true."